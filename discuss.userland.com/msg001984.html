<html>	<head>		<title>Re: The Quake Guy Talks</title>		</head>	<body>		<blockquote><blockquote>			<b>Archive of UserLand's first discussion group, started October 5, 1998.</b><hr>			<h2>Re: The Quake Guy Talks</h2>			<table cellpadding="0" cellspacing="5">				<tr><td><b>Author:</b></td><td>Chuck Shotton</td></tr>				<tr><td><b>Posted:</b></td><td>1/11/1999; 9:45:19 AM</td></tr>				<tr><td><b>Topic:</b></td><td><a href="msg001968.html">The Quake Guy Talks</a></td></tr>				<tr><td><b>Msg #:</b></td><td>1984 (In response to <a href="msg001982.html">1982</a>)</td></tr>				<tr><td><b>Prev/Next:</b></td><td><a href="msg001983.html">1983</a> / <a href="msg001985.html">1985</a></td></tr>				</table>			<br>Here are a few thoughts on several sub-threads within this topic.<p>

I think the telling thing that Carmack points out is his inability to grok memory management. Like most (lazy) developers he prefers to treat memory like an unlimited commodity, forcing the O/S and its virtual memory scheme to cope with undisciplined memory usage at the application level. While it is nice that most modern operating systems can accomodate lazy developer practices, it's wrong to fault only the O/S for not allowing you to write poorly written applications.<p>

It makes you wonder how much better WinTel apps could be if Microsoft didn't give developers the crutch of an unlimited (up to free disk space) pool of memory to swim around in. Carmack's statement that the O/S does a better job of managing memory than an application can do itself is just a pure cop-out. Anyone who has ever written code for a memory constrained machine (whether it's an Apple II, some embedded processor on a F-16, or even a Mac with fixed application memory partitions) can tell you that managing your own memory is orders of magnitude more efficient than assuming an unlimited memory pool and forcing the O/S to deal with your sloppy coding.<p>

As for Carbon, most Mac applications that avoid dorking with the hardware directly should have a minimally impacted transition to Mac OS X. Every piece of code I've got passed the Carbon test suite without a problem except for one which accessed some low memory globals. Since Carbon provides a set of services for accessing low memory globals (or their Carbon analogs), it's a simple matter of replacing variable references with function calls where necessary.<p>

I do have to agree that Apple has done a pretty poor job of documenting and evangelizing Carbon. I know I don't have any "official" stuff on the subject that helps me build Carbon-compliant code now, for example. Apple Developer Support is definitely a weaker organization since Heidi left... :(
			<br><br><hr><b>There are responses to this message:</b><ul><li>&nbsp;<a href="msg001986.html">Oh to be an all-star castmember!</a>, Dave Winer, 1/11/1999; 9:54:07 AM<p><li>&nbsp;<a href="msg001990.html">Re: The Quake Guy Talks</a>, Joseph Palmer, 1/11/1999; 11:33:25 AM<p></ul>			<br><br><hr>This page was archived on 6/13/2001; 4:47:10 PM.<br><br>&copy; Copyright 1998-2001 <a href="http://www.userland.com/">UserLand Software</a>, Inc.			</blockquote></blockquote>		</body>	</html>